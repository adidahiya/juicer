// Generated by CoffeeScript 1.3.3
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(function(require) {
    var $, DEBUG, DEFAULT_IMAGE_SIZE, DEFAULT_ZOOM_LEVEL, SCENE_TOP_PADDING, angular, initAppModule, _;
    _ = require('underscore');
    $ = require('jquery');
    angular = require('angular');
    require('filer');
    DEBUG = false;
    DEFAULT_ZOOM_LEVEL = 50;
    SCENE_TOP_PADDING = 35;
    DEFAULT_IMAGE_SIZE = 100;
    initAppModule = function() {
      var appModule;
      appModule = angular.module('juicer', []);
      appModule.directive('renderWindow', function() {
        return {
          restrict: 'E',
          link: function($scope, $element, attrs) {
            var onMousemove,
              _this = this;
            $scope.rendererWidth = parseInt($element.width());
            $scope.rendererHeight = parseInt($element.height());
            $scope.camera.xOffset = $scope.rendererWidth / 2;
            $scope.camera.yOffset = $scope.rendererHeight / 2;
            $element.mousedown(function(event) {
              return $scope.$apply(function() {
                $scope.pan.isActive = true;
                $scope.pan.xStart = event.pageX;
                return $scope.pan.yStart = event.pageY;
              });
            });
            onMousemove = function(event) {
              if ($scope.pan.isActive) {
                return $scope.$apply(function() {
                  $scope.camera.xOffset += (event.pageX - $scope.pan.xStart) / 20;
                  $scope.camera.yOffset += (event.pageY - $scope.pan.yStart) / 20;
                  return $scope.scrubberChange();
                });
              }
            };
            $element.mousemove(onMousemove);
            $element.mouseup(function(event) {
              return $scope.pan.isActive = false;
            });
            return $element.mouseleave(function(event) {
              return $scope.pan.isActive = false;
            });
          }
        };
      });
      window.JuicerController = function($scope, $timeout) {
        var i, _i, _ref, _ref1;
        $scope.download = function() {
          var data, filer, frame, frames, images, object, renderedProperties, t, _i, _j, _len, _ref, _ref1, _ref2,
            _this = this;
          images = _.map($scope.objects.slice(1), function(obj) {
            return _.pick(obj, 'name');
          });
          frames = [];
          for (t = _i = _ref = $scope.timeStart, _ref1 = $scope.timeEnd; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; t = _ref <= _ref1 ? ++_i : --_i) {
            frame = {};
            _ref2 = $scope.objects.slice(1);
            for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
              object = _ref2[_j];
              renderedProperties = $scope.getObjectStyle(object);
              frame[object.name] = {
                left: "" + (renderedProperties.left - $scope.camera.xOffset) + "px",
                top: "" + (renderedProperties.top - $scope.camera.yOffset) + "px",
                width: "" + renderedProperties.width + "px",
                height: "" + renderedProperties.height + "px"
              };
            }
            frames.push(frame);
          }
          data = {
            camera: {
              width: $('#camera-view').width(),
              height: $('#camera-view').height()
            },
            images: images,
            frames: frames
          };
          filer = new Filer();
          return filer.init({
            persistent: true
          }, function(fs) {
            filer.ls('/', function(entries) {
              return console.log(entries);
            });
            filer.ls('.', function(entries) {
              return console.log(entries);
            });
            return filer.write('juiceAnimation.json', {
              data: JSON.stringify(data),
              type: 'text/json',
              append: false
            }, function(fileEntry, fileWriter) {
              return console.log('success', fileEntry, fileWriter);
            }, function(error) {
              return console.log('error', error);
            });
          }, function(error) {
            return console.log("unable to write to file system: ", error);
          });
        };
        $scope.zoomLevel = DEFAULT_ZOOM_LEVEL;
        $scope.currentScale = 1;
        $scope.zoom = function() {
          var halfHeight, halfWidth, scale, xCenter, yCenter;
          scale = $scope.zoomLevel / DEFAULT_ZOOM_LEVEL;
          halfWidth = $scope.rendererWidth / 2;
          halfHeight = $scope.rendererHeight / 2;
          xCenter = ($scope.camera.xOffset - halfWidth) * scale;
          yCenter = ($scope.camera.yOffset - halfHeight) * scale;
          $scope.camera.xOffset = xCenter + halfWidth;
          $scope.camera.yOffset = yCenter + halfHeight;
          return $scope.currentScale = scale;
        };
        $scope.pan = {
          isActive: false
        };
        $scope.reset = function() {
          $scope.camera.xOffset = $scope.rendererWidth / 2;
          $scope.camera.yOffset = $scope.rendererHeight / 2;
          return $scope.currentScale = 1;
        };
        $scope.time = 0;
        $scope.timeStart = 0;
        $scope.timeEnd = 300;
        $scope.playSpeed = 200;
        $scope.isPaused = true;
        $scope.play = function() {
          $scope.isPaused = false;
          return $scope.playInterval = setInterval(function() {
            return $scope.$apply(function() {
              $scope.time = ($scope.time + 1) % $scope.timeEnd;
              return $scope.scrubberChange();
            });
          }, $scope.playSpeed);
        };
        $scope.pause = function() {
          $scope.isPaused = true;
          return clearInterval($scope.playInterval);
        };
        $scope.setPlaySpeed = function(factor) {
          var didPause;
          if (!$scope.isPaused) {
            $scope.pause();
            didPause = true;
          }
          $scope.playSpeed *= factor;
          if (didPause) {
            return $scope.play();
          }
        };
        $scope.visibleTicks = (function() {
          var _i, _ref, _ref1, _results;
          _results = [];
          for (i = _i = _ref = $scope.timeStart, _ref1 = $scope.timeEnd; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
            _results.push({
              value: i
            });
          }
          return _results;
        })();
        $scope.camera = {
          name: "Camera",
          xOffset: 500,
          yOffset: 250,
          scale: $scope.currentScale
        };
        $scope.objects = [$scope.camera];
        $scope.selectedObject = null;
        $scope.properties = function() {
          return _.keys(_.omit($scope.selectedObject, "name", "$$hashKey", "src"));
        };
        $scope.getObjectStyle = function(object) {
          return {
            left: $scope.currentScale * object.x + $scope.camera.xOffset,
            top: $scope.currentScale * object.y + $scope.camera.yOffset + SCENE_TOP_PADDING,
            width: $scope.currentScale * object.width,
            height: $scope.currentScale * object.height
          };
        };
        $scope.getObjectNames = function() {
          return _.pluck($scope.objects, 'name');
        };
        $scope.addObject = function() {
          var newObject, _i, _ref, _ref1, _ref2, _results;
          if (($scope.newObjectName != null) && !(_ref = $scope.newObjectName, __indexOf.call($scope.getObjectNames(), _ref) >= 0) && ($scope.newObjectSrc != null)) {
            newObject = {
              name: $scope.newObjectName,
              src: $scope.newObjectSrc,
              width: DEFAULT_IMAGE_SIZE,
              height: DEFAULT_IMAGE_SIZE,
              x: -(DEFAULT_IMAGE_SIZE / 2),
              y: -(DEFAULT_IMAGE_SIZE / 2)
            };
            $scope.objects.push(newObject);
            $scope.selectObject(newObject);
            $scope.newObjectName = null;
            _results = [];
            for (i = _i = _ref1 = $scope.timeStart, _ref2 = $scope.timeEnd; _ref1 <= _ref2 ? _i < _ref2 : _i > _ref2; i = _ref1 <= _ref2 ? ++_i : --_i) {
              _results.push($scope.frames[i].bindData(newObject.name, newObject));
            }
            return _results;
          }
        };
        $scope.selectObject = function(object) {
          return $scope.selectedObject = object;
        };
        $scope.isObjectSelected = function(object) {
          return $scope.selectedObject === object;
        };
        $scope.frames = (function() {
          var _i, _ref, _ref1, _results;
          _results = [];
          for (i = _i = _ref = $scope.timeStart, _ref1 = $scope.timeEnd; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
            _results.push({
              keys: {},
              interpolatedValues: {},
              bindData: function(name, object) {
                return this.interpolatedValues[name] = _.clone(object);
              },
              getData: function(name) {
                return this.interpolatedValues[name];
              }
            });
          }
          return _results;
        })();
        for (i = _i = _ref = $scope.timeStart, _ref1 = $scope.timeEnd; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
          $scope.frames[i].bindData($scope.camera.name, $scope.camera);
        }
        $scope.scrubberChange = function() {
          var object, objectValues, prop, _j, _len, _ref2, _results;
          _ref2 = $scope.objects;
          _results = [];
          for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
            object = _ref2[_j];
            objectValues = $scope.frames[$scope.time].getData(object.name);
            _results.push((function() {
              var _k, _len1, _ref3, _results1;
              _ref3 = $scope.properties();
              _results1 = [];
              for (_k = 0, _len1 = _ref3.length; _k < _len1; _k++) {
                prop = _ref3[_k];
                _results1.push(object[prop] = parseFloat(objectValues[prop]));
              }
              return _results1;
            })());
          }
          return _results;
        };
        $scope.setPropertyAtTime = function(property, time, val) {
          return $scope.frames[time].getData($scope.selectedObject.name)[property] = val;
        };
        $scope.setObjectAtTime = function(time, object) {
          var property, _j, _len, _ref2, _results;
          _ref2 = $scope.properties();
          _results = [];
          for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
            property = _ref2[_j];
            _results.push($scope.setPropertyAtTime(property, time, object[property]));
          }
          return _results;
        };
        $scope.addKeyframe = function() {
          if ($scope.selectedObject == null) {
            $scope.error = "No object selected to keyframe.";
            return;
          }
          return $scope.setKeyFrame(parseInt($scope.time));
        };
        $scope.removeKeyframe = function(frames, time, name) {
          var backTime, forwardTime, frame;
          time = parseInt(time);
          frame = frames[time];
          delete frame.keys[name];
          forwardTime = $scope.findKeyFrame(time, $scope.timeEnd, 1, name, frames);
          if (forwardTime === $scope.timeEnd) {
            backTime = $scope.findKeyFrame(time, $scope.timeStart, -1, name, frames);
            if (backTime === $scope.timeStart) {
              return $scope.fill($scope.timeStart, $scope.timeEnd, 1);
            } else {
              return $scope.setKeyFrame(parseInt(backTime));
            }
          } else {
            return $scope.setKeyFrame(parseInt(forwardTime));
          }
        };
        $scope.findKeyFrame = function(timeStart, timeEnd, timeStep, name, frames) {
          while (timeStart !== timeEnd) {
            if (frames[timeStart].keys[name] != null) {
              break;
            }
            timeStart += timeStep;
          }
          return timeStart;
        };
        $scope.fill = function(timeStart, timeEnd, timeStep) {
          var _results;
          _results = [];
          while (timeStart !== timeEnd) {
            $scope.setObjectAtTime(timeStart, $scope.selectedObject);
            _results.push(timeStart += timeStep);
          }
          return _results;
        };
        $scope.interpolate = function(timeStart, timeEnd, timeStep, name, frames) {
          var getDifference, objectDifference, objectEnd, objectStart, property, rv, t, time, _j, _len, _ref2, _results;
          getDifference = function(objectStart, objectEnd) {
            var dProp, dT, difference, property, _j, _len, _ref2;
            difference = {};
            _ref2 = $scope.properties();
            for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
              property = _ref2[_j];
              dProp = objectEnd[property] - objectStart[property];
              dT = timeEnd - timeStart;
              difference[property] = parseFloat(dProp / dT);
            }
            return difference;
          };
          objectStart = frames[timeStart].getData(name);
          objectEnd = frames[timeEnd].getData(name);
          objectDifference = getDifference(objectStart, objectEnd);
          t = 0;
          _results = [];
          while (timeStart + t !== timeEnd) {
            time = timeStart + t;
            _ref2 = $scope.properties();
            for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
              property = _ref2[_j];
              rv = parseFloat(objectStart[property]) + objectDifference[property] * t;
              $scope.setPropertyAtTime(property, time, rv.toFixed(3));
            }
            _results.push(t += timeStep);
          }
          return _results;
        };
        return $scope.setKeyFrame = function(time) {
          var frames, name, runInterpolationWalk;
          $scope.frames[time].keys[$scope.selectedObject.name] = true;
          $scope.setObjectAtTime(time, $scope.selectedObject);
          runInterpolationWalk = function(timeStart, timeBound, timeStep, name, frames) {
            var projection, timeEnd;
            projection = timeStart + timeStep;
            if (($scope.timeStart <= projection && projection <= $scope.timeEnd)) {
              timeEnd = $scope.findKeyFrame(projection, timeBound, timeStep, name, frames);
              if (timeEnd === timeBound) {
                return $scope.fill(timeStart, timeEnd, timeStep);
              } else {
                return $scope.interpolate(timeStart, timeEnd, timeStep, name, frames);
              }
            }
          };
          name = $scope.selectedObject.name;
          frames = $scope.frames;
          runInterpolationWalk(time, $scope.timeStart - 1, -1, name, frames);
          return runInterpolationWalk(time, $scope.timeEnd, 1, name, frames);
        };
      };
      return window.JuicerController.$inject = ['$scope', '$timeout'];
    };
    return {
      init: function() {
        initAppModule();
        return angular.bootstrap(document, ['juicer']);
      }
    };
  });

}).call(this);
